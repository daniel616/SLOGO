#Part 1

1. What about your API/design is intended to be flexible?
My API is flexible by allowing for multiple turtles to be created and containing all of the states of a turtle in a discrete package that the back end can modify and the front end can look for. The GUI API is flexible because all of the independent screen-like objects can be positioned in the GUI without changing their character or functionality. The commands API is flexible because more commands can be added without changing the front end or other back end classes.

2. How is your API/design encapsulating your implementation decisions?
The buttons often are used to pass information between the front and back end so that the implementation is hidden from the user and other classes/objects. Also, the commands class will hide how it parses out different commands to different subclasses of commands for appropriate parsing by having the same method, execute(Turtle t), be called for every type of command. 

3. What exceptions (error cases) might occur in your part and how will you handle them (or not, by throwing)?
All errors relating to bad command input will be handled by displaying the error message to the output console screen. This means that bad parameter type or bad command name will display to the user.

4. Why do you think your API/design is good (also define what your measure of good is)?
To me a good API does not have too many methods and is small enough in size to that clients will know where to look for the methods that they desire. Either having a small subset of classes handle all API details or having few methods per each class in the front or back ends would be a good API design decision. Per this definition, my API is fairly good in that buttons almost exclusively pass information from the front to back end and then the front end only needs look at the turtles list or the other commands list to display results of the back end to the GUI.

#Part 2

1. How do you think Design Patterns are currently represented in the design or could be used to help improve the design?
Our team currently employs the command design pattern to handle all of the commands that the user can enter into the console. This means that we will have a bunch of subclasses for all the commands, but that each will contain an execute method that can do everything a command should be able to accomplish. We also will use an iterator to loop through all of the turtle objects to get their updated states after a command sequence has been passed to the back end. We certainly will also make use of private class data for almost every class. Chain of responsibility will become important when passing commands to the back end so that they can be parsed and passed to a turtle (or not) in the correct sequence. To improve our design, I think that we will try to implement chain of responsibility further so that the nested commands can be handled in the correct order. Also we will try to implement observer so that the actual turtle list does not need to be passed around from the front to back end and vice versa and instead can be observed. 
2. How do you think the "advanced" Java features will help you implement your design?
Binding will certainly help out by linking button pushes in the front end to updating turtle states and executing other commands in the back end without having to go through a controller in the middle between the view and the model. This could simplify our design in this project, but it definitely makes the front and back end more linked. Also, reflection will be useful for the implementation of deciding which class needs to be created to execute a specific command passed in on the front end. 
3. What feature/design problem are you most excited to work on?
I am most excited to work on actually implementing the updating of turtle states using an observer and having the front end be able to tell the back end that it has observed all current states so they should be deleted so as to not be observed again. This is crucial to the functioning of the program and will be more difficult to implement without actually passing the turtle objects between the back and front ends, but I understand that the observer way will keep these more separate.
4. What feature/design problem are you most worried about working on?
I am most worried about working on how to allow flexibility in the GUI, especially the turtle screen, which is the code I am currently dealing with. I want to make sure that I use resource files for all text and CSS for my styling so that they can be modified if needed, but I've never done this before, so there will be a lot to read about. I am also worried about making sure the user can change a lot of aspects of the GUI, whether it be a color of a background or a speed by which the turtle moves on the screen. I will need to learn how to take in and implement user commands well instead of hard coding things. 
5. Come up with at least five use cases for your part (it is absolutely fine if they are useful for both teams).
* "k* 100" The user would press the run button and this command would be passed to the parser, which would read it in and determine that the command is not found. This error would be thrown up to the GUI and displayed on the console output screen. 
* "Choosing a new turtle image" A file chooser will pop up in the correct directory and allow the user to choose from a list of jpg or gif files that could be the turtle image. This is called by a button that will open the file chooser and then the turtle object's image will be updated on the canvas. 
* "Setting the pen color" A button will bring up a color wheel that sets the pen color in the turtle screen class until it is changed later on. 
* "Choosing the language in which commands are accepted" A dropdown box will allow the user to select from a list of languages currently supported and then selecting the language will change the resource file from which commands are read. 
* "Help button is pressed" A pop up window will be shown that shows the user a list of all the commands that can be input into the command line and how to use them along with some tips about how to use the GUI for common functions. 